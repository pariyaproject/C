#ifndef DETAIL_CLASS_H
#define DETAIL_CLASS_H
#include <iostream>

//类
//一个类通过定义五种特殊的成员函数来控制操作
//拷贝构造函数
//拷贝赋值运算符  
//移动构造函数
//移动赋值运算符
//析构函数
//
//拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么
//拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么
//析构就是此类型对象销毁时做什么
//以上操作称为拷贝控制操作,没有显式定义,编译器会补上

//如果一个构造函数的第一个参数是自身类型的引用,[且任何额外参数都有默认值]
//则此构造函数是拷贝构造函数
//Foo();  //默认构造函数
//Foo(const Foo&);  //拷贝构造函数(一般是const)
//拷贝构造函数在几种情况下会被隐式地使用,因此不应该量explicit的
//合成拷贝构造函数,由编译器定义,与合成默认构造函数不同,即使有定义了其他的构造函数,编译器也会合成一个拷贝构造函数 
//某情况下合成拷贝构造函数用来阻止拷贝该类类型的对象,
//而一般情况下,合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中
//编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中
//每个成员的类型决定了它如何拷贝:类=>拷贝构造函数 内置类型=>直接拷贝
//虽然不能直接拷贝一个数组,但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员(成员类型同上)

//string dots(10,' ');				//直接初始化
//string s(dots);					//直接初始化
//string d2 = dots;					//拷贝初始化
//string null_book = "9-999-99";	//拷贝初始化
//string nines = string(100,'9');	//拷贝初始化
//当使用直接初始化时,实际上是要求编译器使用普通的函数匹配选择参数最匹配的构造函数
//当使用拷贝初始化时,要求编译器将右侧运算对象拷贝到正在创建的对象中,需要的话还要进行类型转换



#endif